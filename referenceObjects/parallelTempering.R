parallelTemperingSimulation <- setRefClass(
	Class		= "ParallelTempering",

	contains	= "Simulations",

	fields		= list(
									# User provided		
		temperatures		= "numeric",
		inverseTemperatures = "numeric",
									# Autogenerated
		noOfChains		= "integer",	
		strategyNumber 		= "integer",
									# Possible export to some data structure.
		simultatedStates	= "matrix",				
		currentStatesLogDensities= "matrix",
		currentStates 		= "matrix",
		proposalsCovarianceCholeskised = "matrix",
		quasiMetric  		= "function",
		translatorFromLexicOrderToTranspositions = "matrix"

	),

	methods 	= list(	
		
		numeration	= function(
			iteration 	= 0, 
			type 		= 'init'
		)
		{
			init <- if (type =='init') 1 else 
					if (type =='RW')   (2*iteration - 1)*problemDimension+1 else
					if (type =='Swap') 2*iteration*problemDimension +1

			return( init:(init+problemDimension-1))
		},

		parallelTemperingInitializator	= function(
			temperatures 	= numeric(0),
			...
			)
		{
			if (length(temperatures) == 0) 
			{
				cat('I did not receive any temperatures. I shall therefore proceed with rather arbitrary choice of 5 temperature levels 1<2<3<4<5.')
			} else
			{
				if (any( temperatures <= 1 )) cat('Do you really want to cool down the distribution? That does not make sense, does it? Try avoiding such things.')
				
				tmpTemp						<- temperatures
				tmpTemp[length(tmpTemp)+1] 	<- 1
				tmpTemp 					<- sort(tmpTemp, decreasing=FALSE) 
				temperatures 		<<- tmpTemp	
				inverseTemperatures <<- 1/tmpTemp

				noOfChains 		<<- length(tmpTemp)

				simultatedStates <<- 
					matrix(
						nrow = problemDimension*(2*noOfSteps + 1), 
						ncol = noOfChains
					)
			}
		},

		initializeDataStructures = function(
			initialPoints		= matrix(nrow=0, ncol=0),
			quasiMetric			= NULL,
			strategyNumber 		= 1 
			)
		{
			if (nrow(initialPoints)==0 | ncol(initialPoints) ==0 )
			{
				if (problemDimension==0) cat("I do not know the problem dimension and so cannot autogenerate any starting points.") 
				else if (noOfChains==0) cat("I do not know how many chains are needed and so cannot autogenerate any starting points.") 
				else 
				{
						#autogenerate starting points uniformly from a hypercube
						currentStates <<- 
							replicate( 
								n 	= noOfChains, 
								expr= runif( 
									n = problemDimension,
									min=0,
									max=10 
								)
							)
				}	
			} 
			else
			{
				currentStates	<<- initialPoints 
			}		

			quasiMetric <<- quasiMetric
			simultatedStates[numeration(),] <<- currentStates 
			
			tmpStrategyNumber	<- as.integer(strategyNumber)

			if ( is.na(tmpStrategyNumber) || (tmpStrategyNumber < 0) ) 
			{
				stop("Inappropriate stregy number. Please enter an integer value.")
			} else
			{	
				strategyNumber	<<- tmpStrategyNumber
			}

			if (noOfChains >= 1) translatorFromLexicOrderToTranspositions <<- 
				generateTranslatorFromLexicalOrderToTranspositions( 1:noOfChains ) 
		},

		initialize 				= function(
			noOfSteps 			= 0L,
			problemDimension	= 0L,
			targetDensity 		= NULL, 
			initialPoints		= matrix(nrow=0, ncol=0),
			temperatures 		= numeric(0),
			quasiMetric 		= NULL,
			strategyNumber		= 1L
			)
		{
				#fills standard fields.
			simulationInitializator(
				noOfSteps 		=noOfSteps, 
				problemDimension=problemDimension,
				targetDensity 	= targetDensity,
				initialPoints 	= initialPoints
				)

			parallelTemperingInitializator( 
				temperatures,
				quasiMetric,
				strategyNumber 
				)

			initializeDataStructures( initialPoints )
		},
	
		makeStepOfTheAlgorithm	= function()
		{
			print('I shall make it all happen for PT.')
		},

		parallelTemperingShow	= function()
		{
			cat('\nThe Parallel Tempering inputs are here: \n')
			cat('Temperatures: ', temperatures, '\n')
			cat('Number of chains: ', noOfChains, '\n')	
			cat('Chosen strategy number: ', strategyNumber, '\n')	
			cat('Initial Points:\n')		

			initialStates 			<- as.data.frame( simultatedStates[numeration(),] )
			names( initialStates ) 	<- temperatures
			print(initialStates)	
		},

		show	= function()
		{
			simulationShow()
			parallelTemperingShow()			
		},

		swapStrategy = function(
			chosenIndices 	,
			strategyNumber 	=1
		)	
		{
			i <- chosenIndices[1]
			j <- chosenIndices[2] 	
			s <- strategyNumber

			tmp <- currentStatesLogDensities[i] - currentStatesLogDensities[j]

			tmp <- 
				exp(
					ifelse( s==2, -tmp, -abs(tmp) )*
					ifelse( s==3|s==4 , inverseTemperatures[i] - inverseTemperatures[j], 1)*
					ifelse( s ==4,
						1/(1 + quasiMetric( 	currentStates[,i],
												currentStates[,j] ) ),
						1 
					)
				) 

			tmp <- ifelse( s==2 & tmp >1, 1, tmp )
			
			return( tmp )	
		},

			# See testing.R for comparison of speeds.
		generateTranslatorFromLexicalOrderToTranspositions = function(
			inputIndices
		)
		{
			noOfIndices 	<- length(inputIndices)
			
			if ( noOfIndices > 0)
			{
				if (noOfIndices > 1)
				{
					result<-lapply( 
						1:(noOfIndices -1),
						function( number )
						{
							noOfCols	<- noOfIndices-number
							return( 
								matrix( 
									c( 
										rep.int(x=inputIndices[number], times=noOfCols), 
										inputIndices[ (number+1):noOfIndices] 
									), 
									ncol = noOfCols,
									nrow = 2,
									byrow= TRUE 
								)
							)							
						}
					)				
				}
			} else
			{	
				stop('A problem of type in generation.')
			}				
			return(	do.call(cbind, result) )
		},

		makeStepOfTheAlgorithm	= function()
		{
			
		},

		updateLogsOfUnnormalisedDensities = function(
			indicesOfStatesToUpdate
		)
		{
			return(
				log(
					apply( 
						Current_States[,indicesOfStatesToUpdate], 
						2, 
						targetDensity 
					)
				)	
			)
		}
	)
)

								# No adaptation for now.
parallelTemperingSimulation$lock( 
	'temperatures',
	'inverseTemperatures',
	'noOfChains',
	'proposalsCovarianceCholeskised',
	'quasiMetric',
	'strategyNumber'
)