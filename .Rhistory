stop("First arg must be the result of death_curve")
if (missing(conf.int)) {
if (is.null(x$strata) && !is.matrix(x$surv))
conf.int <- TRUE
else conf.int <- FALSE
}
if (is.null(x$strata)) {
nstrat <- 1
stemp <- rep(1, length(x$time))
}
else {
nstrat <- length(x$strata)
stemp <- rep(1:nstrat, x$strata)
}
ssurv <- x$surv
stime <- x$time
supper <- x$upper
slower <- x$lower
if (!missing(xmax) && any(x$time > xmax)) {
keepx <- keepy <- NULL
yzero <- NULL
tempn <- table(stemp)
offset <- cumsum(c(0, tempn))
for (i in 1:nstrat) {
ttime <- stime[stemp == i]
if (all(ttime <= xmax)) {
keepx <- c(keepx, 1:tempn[i] + offset[i])
keepy <- c(keepy, 1:tempn[i] + offset[i])
}
else {
bad <- min((1:tempn[i])[ttime > xmax])
if (bad == 1) {
keepy <- c(keepy, 1 + offset[i])
yzero <- c(yzero, 1 + offset[i])
}
else keepy <- c(keepy, c(1:(bad - 1), bad - 1) +
offset[i])
keepx <- c(keepx, (1:bad) + offset[i])
stime[bad + offset[i]] <- xmax
x$n.event[bad + offset[i]] <- 1
}
}
stime <- stime[keepx]
stemp <- stemp[keepx]
x$n.event <- x$n.event[keepx]
if (is.matrix(ssurv)) {
if (length(yzero))
ssurv[yzero, ] <- firsty
ssurv <- ssurv[keepy, , drop = FALSE]
if (!is.null(supper)) {
if (length(yzero))
supper[yzero, ] <- slower[yzero, ] <- firsty
supper <- supper[keepy, , drop = FALSE]
slower <- slower[keepy, , drop = FALSE]
}
}
else {
if (length(yzero))
ssurv[yzero] <- firsty
ssurv <- ssurv[keepy]
if (!is.null(supper)) {
if (length(yzero))
supper[yzero] <- slower[yzero] <- firsty
supper <- supper[keepy]
slower <- slower[keepy]
}
}
}
stime <- stime/xscale
if (!missing(fun)) {
if (is.character(fun)) {
tfun <- switch(fun, log = function(x) x, event = function(x) 1 -
x, cumhaz = function(x) -log(x), cloglog = function(x) log(-log(x)),
pct = function(x) x * 100, logpct = function(x) 100 *
x, stop("Unrecognized function argument"))
if (fun == "log" || fun == "logpct")
logy <- TRUE
if (fun == "cloglog") {
logx <- TRUE
if (logy)
logax <- "xy"
else logax <- "x"
}
}
else if (is.function(fun))
tfun <- fun
else stop("Invalid 'fun' argument")
ssurv <- tfun(ssurv)
if (!is.null(supper)) {
supper <- tfun(supper)
slower <- tfun(slower)
}
firsty <- tfun(firsty)
ymin <- tfun(ymin)
}
if (is.null(x$n.event))
mark.time <- FALSE
if (is.matrix(ssurv))
ncurve <- nstrat * ncol(ssurv)
else ncurve <- nstrat
mark <- rep(mark, length.out = ncurve)
col <- rep(col, length.out = ncurve)
lty <- rep(lty, length.out = ncurve)
lwd <- rep(lwd, length.out = ncurve)
if (is.numeric(mark.time))
mark.time <- sort(mark.time)
if (xaxs == "S") {
xaxs <- "i"
tempx <- max(stime) * 1.04
}
else tempx <- max(stime)
tempx <- c(firstx, tempx, firstx)
if (logy) {
tempy <- range(ssurv[is.finite(ssurv) & ssurv > 0])
if (tempy[2] == 1)
tempy[2] <- 0.99
if (any(ssurv == 0)) {
tempy[1] <- tempy[1] * 0.8
ssurv[ssurv == 0] <- tempy[1]
if (!is.null(supper)) {
supper[supper == 0] <- tempy[1]
slower[slower == 0] <- tempy[1]
}
}
tempy <- c(tempy, firsty)
}
else tempy <- c(range(ssurv[is.finite(ssurv)]), firsty)
if (missing(fun)) {
tempx <- c(tempx, firstx)
tempy <- c(tempy, ymin)
}
plot(tempx, 1 - tempy * yscale, type = "n", log = logax, xlab = xlab,
ylab = ylab, xaxs = xaxs, ...)
if (yscale != 1) {
if (logy)
par(usr = par("usr") - c(0, 0, log10(yscale), log10(yscale)))
else par(usr = par("usr")/c(1, 1, yscale, yscale))
}
dostep <- function(x, y) {
if (is.na(x[1] + y[1])) {
x <- x[-1]
y <- y[-1]
}
n <- length(x)
if (n > 2) {
dupy <- c(!duplicated(y)[-n], TRUE)
n2 <- sum(dupy)
xrep <- rep(x[dupy], c(1, rep(2, n2 - 1)))
yrep <- rep(y[dupy], c(rep(2, n2 - 1), 1))
list(x = xrep, y = yrep)
}
else if (n == 1)
list(x = x, y = y)
else list(x = x[c(1, 2, 2)], y = y[c(1, 1, 2)])
}
i <- 0
xend <- NULL
yend <- NULL
for (j in unique(stemp)) {
who <- (stemp == j)
xx <- c(firstx, stime[who])
nn <- length(xx)
if (x$type == "counting") {
deaths <- c(-1, x$n.censor[who])
zero.one <- 1
}
else if (x$type == "right") {
deaths <- c(-1, x$n.event[who])
zero.one <- 0
}
if (is.matrix(ssurv)) {
for (k in 1:ncol(ssurv)) {
i <- i + 1
yy <- c(firsty, ssurv[who, k])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
if (is.numeric(mark.time)) {
indx <- mark.time
for (k in seq(along.with = mark.time)) indx[k] <- sum(mark.time[k] >
xx)
points(mark.time[indx < nn], yy[indx[indx <
nn]], pch = mark[i], col = col[i], cex = cex)
}
else if (mark.time && any(deaths == zero.one)) {
points(xx[deaths == zero.one], yy[deaths ==
zero.one], pch = mark[i], col = col[i], cex = cex)
}
xend <- c(xend, max(xx))
yend <- c(yend, min(yy))
if (conf.int && !is.null(supper)) {
if (ncurve == 1)
lty[i] <- lty[i] + 1
yy <- c(firsty, supper[who, k])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
yy <- c(firsty, slower[who, k])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
}
}
}
else {
i <- i + 1
yy <- c(firsty, ssurv[who])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
if (is.numeric(mark.time)) {
indx <- mark.time
for (k in seq(along = mark.time)) indx[k] <- sum(mark.time[k] >
xx)
points(mark.time[indx < nn], yy[indx[indx < nn]],
pch = mark[i], col = col[i], cex = cex)
}
else if (mark.time == TRUE && any(deaths == zero.one)) {
points(xx[deaths == zero.one], yy[deaths == zero.one],
pch = mark[i], col = col[i], cex = cex)
}
xend <- c(xend, max(xx))
yend <- c(yend, min(yy))
if (conf.int == TRUE && !is.null(supper)) {
if (ncurve == 1)
lty[i] <- lty[i] + 1
yy <- c(firsty, supper[who])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
yy <- c(firsty, slower[who])
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
}
}
}
invisible(list(x = xend, y = yend))
}
plot(model)
?dostep
??dostep
?lines
dostep(1:10, 11:20)
plot.death_curve <- function (x, conf.int, mark.time = TRUE, mark = 3, col = 1, lty = 1,
lwd = 1, cex = 1, log = FALSE, xscale = 1, yscale = 1, firstx = 0,
firsty = 1, xmax, ymin = 0, fun, xlab = "", ylab = "", xaxs = "S",
...)
{
<<<<<<< HEAD
dotnames <- names(list(...))
if (any(dotnames == "type"))
stop("The graphical argument 'type' is not allowed")
if (is.logical(log)) {
logy <- log
logx <- FALSE
if (logy)
logax <- "y"
else logax <- ""
}
else {
logy <- (log == "y" || log == "xy")
logx <- (log == "x" || log == "xy")
logax <- log
}
if (missing(firstx)) {
if (!is.null(x$start.time))
firstx <- x$start.time
else {
if (logx || (!missing(fun) && is.character(fun) &&
fun == "cloglog"))
firstx <- min(x$time[x$time > 0])
else firstx <- min(0, x$time)
}
}
firstx <- firstx/xscale
if (missing(xaxs) && firstx != 0)
xaxs <- par("xaxs")
if (!inherits(x, "death_curve"))
stop("First arg must be the result of death_curve")
if (missing(conf.int)) {
if (is.null(x$strata) && !is.matrix(x$surv))
conf.int <- TRUE
else conf.int <- FALSE
}
if (is.null(x$strata)) {
nstrat <- 1
stemp <- rep(1, length(x$time))
}
else {
nstrat <- length(x$strata)
stemp <- rep(1:nstrat, x$strata)
}
ssurv <- x$surv
stime <- x$time
supper <- x$upper
slower <- x$lower
if (!missing(xmax) && any(x$time > xmax)) {
keepx <- keepy <- NULL
yzero <- NULL
tempn <- table(stemp)
offset <- cumsum(c(0, tempn))
for (i in 1:nstrat) {
ttime <- stime[stemp == i]
if (all(ttime <= xmax)) {
keepx <- c(keepx, 1:tempn[i] + offset[i])
keepy <- c(keepy, 1:tempn[i] + offset[i])
}
else {
bad <- min((1:tempn[i])[ttime > xmax])
if (bad == 1) {
keepy <- c(keepy, 1 + offset[i])
yzero <- c(yzero, 1 + offset[i])
}
else keepy <- c(keepy, c(1:(bad - 1), bad - 1) +
offset[i])
keepx <- c(keepx, (1:bad) + offset[i])
stime[bad + offset[i]] <- xmax
x$n.event[bad + offset[i]] <- 1
}
}
stime <- stime[keepx]
stemp <- stemp[keepx]
x$n.event <- x$n.event[keepx]
if (is.matrix(ssurv)) {
if (length(yzero))
ssurv[yzero, ] <- firsty
ssurv <- ssurv[keepy, , drop = FALSE]
if (!is.null(supper)) {
if (length(yzero))
supper[yzero, ] <- slower[yzero, ] <- firsty
supper <- supper[keepy, , drop = FALSE]
slower <- slower[keepy, , drop = FALSE]
}
}
else {
if (length(yzero))
ssurv[yzero] <- firsty
ssurv <- ssurv[keepy]
if (!is.null(supper)) {
if (length(yzero))
supper[yzero] <- slower[yzero] <- firsty
supper <- supper[keepy]
slower <- slower[keepy]
}
}
}
stime <- stime/xscale
if (!missing(fun)) {
if (is.character(fun)) {
tfun <- switch(fun, log = function(x) x, event = function(x) 1 -
x, cumhaz = function(x) -log(x), cloglog = function(x) log(-log(x)),
pct = function(x) x * 100, logpct = function(x) 100 *
x, stop("Unrecognized function argument"))
if (fun == "log" || fun == "logpct")
logy <- TRUE
if (fun == "cloglog") {
logx <- TRUE
if (logy)
logax <- "xy"
else logax <- "x"
}
}
else if (is.function(fun))
tfun <- fun
else stop("Invalid 'fun' argument")
ssurv <- tfun(ssurv)
if (!is.null(supper)) {
supper <- tfun(supper)
slower <- tfun(slower)
}
firsty <- tfun(firsty)
ymin <- tfun(ymin)
}
if (is.null(x$n.event))
mark.time <- FALSE
if (is.matrix(ssurv))
ncurve <- nstrat * ncol(ssurv)
else ncurve <- nstrat
mark <- rep(mark, length.out = ncurve)
col <- rep(col, length.out = ncurve)
lty <- rep(lty, length.out = ncurve)
lwd <- rep(lwd, length.out = ncurve)
if (is.numeric(mark.time))
mark.time <- sort(mark.time)
if (xaxs == "S") {
xaxs <- "i"
tempx <- max(stime) * 1.04
}
else tempx <- max(stime)
tempx <- c(firstx, tempx, firstx)
if (logy) {
tempy <- range(ssurv[is.finite(ssurv) & ssurv > 0])
if (tempy[2] == 1)
tempy[2] <- 0.99
if (any(ssurv == 0)) {
tempy[1] <- tempy[1] * 0.8
ssurv[ssurv == 0] <- tempy[1]
if (!is.null(supper)) {
supper[supper == 0] <- tempy[1]
slower[slower == 0] <- tempy[1]
}
}
tempy <- c(tempy, firsty)
}
else tempy <- c(range(ssurv[is.finite(ssurv)]), firsty)
if (missing(fun)) {
tempx <- c(tempx, firstx)
tempy <- c(tempy, ymin)
}
plot(tempx, 1 - tempy * yscale, type = "n", log = logax, xlab = xlab,
ylab = ylab, xaxs = xaxs, ...)
if (yscale != 1) {
if (logy)
par(usr = par("usr") - c(0, 0, log10(yscale), log10(yscale)))
else par(usr = par("usr")/c(1, 1, yscale, yscale))
}
dostep <- function(x, y) {
if (is.na(x[1] + y[1])) {
x <- x[-1]
y <- y[-1]
}
n <- length(x)
if (n > 2) {
dupy <- c(!duplicated(y)[-n], TRUE)
n2 <- sum(dupy)
xrep <- rep(x[dupy], c(1, rep(2, n2 - 1)))
yrep <- rep(y[dupy], c(rep(2, n2 - 1), 1))
list(x = xrep, y = yrep)
}
else if (n == 1)
list(x = x, y = y)
else list(x = x[c(1, 2, 2)], y = y[c(1, 1, 2)])
}
i <- 0
xend <- NULL
yend <- NULL
for (j in unique(stemp)) {
who <- (stemp == j)
xx <- c(firstx, stime[who])
nn <- length(xx)
if (x$type == "counting") {
deaths <- c(-1, x$n.censor[who])
zero.one <- 1
}
else if (x$type == "right") {
deaths <- c(-1, x$n.event[who])
zero.one <- 0
}
if (is.matrix(ssurv)) {
for (k in 1:ncol(ssurv)) {
i <- i + 1
yy <- c(firsty, ssurv[who, k])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
if (is.numeric(mark.time)) {
indx <- mark.time
for (k in seq(along.with = mark.time)) indx[k] <- sum(mark.time[k] >
xx)
points(mark.time[indx < nn], yy[indx[indx <
nn]], pch = mark[i], col = col[i], cex = cex)
}
else if (mark.time && any(deaths == zero.one)) {
points(xx[deaths == zero.one], yy[deaths ==
zero.one], pch = mark[i], col = col[i], cex = cex)
}
xend <- c(xend, max(xx))
yend <- c(yend, min(yy))
if (conf.int && !is.null(supper)) {
if (ncurve == 1)
lty[i] <- lty[i] + 1
yy <- c(firsty, supper[who, k])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
yy <- c(firsty, slower[who, k])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
}
}
}
else {
i <- i + 1
yy <- c(firsty, ssurv[who])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
if (is.numeric(mark.time)) {
indx <- mark.time
for (k in seq(along = mark.time)) indx[k] <- sum(mark.time[k] >
xx)
points(mark.time[indx < nn], yy[indx[indx < nn]],
pch = mark[i], col = col[i], cex = cex)
}
else if (mark.time == TRUE && any(deaths == zero.one)) {
points(xx[deaths == zero.one], yy[deaths == zero.one],
pch = mark[i], col = col[i], cex = cex)
}
xend <- c(xend, max(xx))
yend <- c(yend, min(yy))
if (conf.int == TRUE && !is.null(supper)) {
if (ncurve == 1)
lty[i] <- lty[i] + 1
yy <- c(firsty, supper[who])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
yy <- c(firsty, slower[who])
yy <- 1 - yy
lines(dostep(xx, yy), lty = lty[i], col = col[i],
lwd = lwd[i])
}
}
}
invisible(list(x = xend, y = yend))
}
plot(model)
=======
return(
SIMULATION(
Liang_No_of_Chains,
100,	# No of Steps of the algorithm
Liang_Problem_Dimension,
Liang_Initial_Points,
LIANG_TARGET_DENSITY,
STRATEGY_THREE,
EASY_METRIC,
Liang_Proposals_Covariance_Choleskised_Enlisted,
Liang_Inverse_Temperatures
)
)
}
M <- G()
M
ls()
Liang_Distribution_Values
Grid 				<- seq(-2, 12, by=.2)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
class(Liang_Distribution_Values)
Liang_Distribution_Values   <- as.matrix(read.csv2("./Data/Liang_Density_Values.csv")	)
class(Liang_Distribution_Values)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
a <- seq(1,20)
b <- a^0.25
plot(a,b, bty = "l")
df <- as.data.frame(cbind(a,b))
ggplot(df, aes(x = a, y = b)) + geom_point()
source('~/.active-rstudio-document', echo=TRUE)
library(ggplot2)
df <- as.data.frame(cbind(a,b))
ggplot(df, aes(x = a, y = b)) + geom_point()
ggplot(df, aes(x = a, y = b)) + geom_point() + theme(panel.background = element_rect(fill='white', colour='black'))
ggplot(df, aes(x = a, y = b)) + geom_point() + theme(panel.background = element_blank(fill='white', colour='black')) + theme(panel.grid.major = none, panel.grid.minor = none) + theme( panel.border = theme_L_border())
Liang3D <- head(melt(Liang_Distribution_Values))
colnames(Liang3D) <- c("x","y","z")
rm(list = ls())
directory <- "/home/matteo/Documents/Scienza/Laurea_di_Matematica/Implementation"
rm(directory)
library(mvtnorm)
source("./Distributions_to_check/tested_distribution.R")
source("./Functions/simulation_mechanism.R")
source("./Functions/additional_functions.R")
source("./Strategies_to_check/tested_strategies.R")
source("./Distributions_to_check/Liang_Example.R")
Grid 				<- seq(-2, 12, by=.2)
Liang_Distribution_Values   <- as.matrix(read.csv2("./Data/Liang_Density_Values.csv")	)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
class(Liang_Distribution_Values)
v <- ggplot(Liang3D, aes(x, y, z = z))
v<- ggplot(aes(x=Grid, y=Grid, z=Liang_Distribution_Values))
ggplot(df, aes(x = a, y = b)) + geom_point() + theme(panel.background = element_blank(fill='white', colour='black')) + theme(panel.grid.major = none, panel.grid.minor = none) + theme( panel.border = theme_L_border())
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
nlevels = 5,
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = pretty(nlevels), nlevels = 20,
col=color.palette(length(nlevels)-1)
)
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = good_levels,
col=colorRampPalette(c("white", "blue"), space = "Lab")(length(good_levels)-1)
)
library(graphics)
good_levels <- pretty(range(Liang_Distribution_Values, finite=TRUE), 20)
colorRampPalette(c('dark red','white','dark blue'))
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = good_levels,
col=terrain.colors(length(good_levels)-1)
)
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = good_levels,
col=colorRampPalette(c("white", "blue"), space = "Lab")(length(good_levels)-1)
)
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
nlevels = 5,
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
nlevels = 5,
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
nlevels = 20
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
nlevels = 5,
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
summary(volcano)
head(volcano)
head(melt(volcano))
library(reshape2)
head(melt(volcano))
v <- ggplot(volcano3d, aes(x, y, z = z))
volcano3d <- melt(volcano)
names(volcano3d) <- c("x", "y", "z")
v <- ggplot(volcano3d, aes(x, y, z = z))
v + stat_contour()
Liang_Distribution_Values
head(Liang_Distribution_Values)
melt(Liang_Distribution_Values)
Liang3D <- head(melt(Liang_Distribution_Values))
colnames(Liang3D) <- c("x","y","z")
v <- ggplot(Liang3D, aes(x, y, z = z))
v + stat_contour()
Z <- Liang_Distribution_Values
colnames(Z) <- c()
Liang3D <- head(melt(Z))
colnames(Liang3D) <- c("x","y","z")
v <- ggplot(Liang3D, aes(x, y, z = z))
v + stat_contour()
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = pretty(nlevels), nlevels = 20,
col=color.palette(length(nlevels)-1)
)
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
length(M)
points(c(4,8))
head(melt(volcano))
Liang3D <- head(melt(Z))
length(Liang3D)
dim(Liang3D)
Z <- Liang_Distribution_Values
Z
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
xlim = range(Grid, finite = TRUE),
ylim = range(Grid, finite = TRUE),
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
xlim = range(Grid, finite = TRUE),
ylim = range(Grid, finite = TRUE),
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
nlevels = 10
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
xlim = range(Grid, finite = TRUE),
ylim = range(Grid, finite = TRUE),
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
nlevels = 15
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
xlim = range(Grid, finite = TRUE),
ylim = range(Grid, finite = TRUE),
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
xlim = range(Grid, finite = TRUE),
range(Grid, finite = TRUE),
range(Grid, finite = TRUE)
range(Grid, finite = TRUE)[1]
points(c(4,8)+c(range(Grid, finite = TRUE)[1]
,range(Grid, finite = TRUE)[1]
))
points(c(4,8))
points(c(0,0))
rm(list = ls())
directory <- "/home/matteo/Documents/Scienza/Laurea_di_Matematica/Implementation"
getwd()
setwd(directory)
rm(directory)
library(mvtnorm)
source("./Distributions_to_check/tested_distribution.R")
source("./Functions/simulation_mechanism.R")
source("./Functions/additional_functions.R")
source("./Strategies_to_check/tested_strategies.R")
ls()
source("./Distributions_to_check/Liang_Example.R")
Grid 				<- seq(-2, 12, by=.2)
Liang_Distribution_Values   <- as.matrix(read.csv2("./Data/Liang_Density_Values.csv")	)
persp(Grid,Grid, Liang_Distribution_Values , theta = 12, phi = 30)
COORDINATE_PROPOSITION(1:2, 2, LIANG_TARGET_DENSITY, diag(Liang_Temperatures[1]/16, nrow=2, ncol=2))
G <- function()
{
return(
SIMULATION(
Liang_No_of_Chains,
100,	# No of Steps of the algorithm
Liang_Problem_Dimension,
Liang_Initial_Points,
LIANG_TARGET_DENSITY,
STRATEGY_THREE,
EASY_METRIC,
Liang_Proposals_Covariance_Choleskised_Enlisted,
Liang_Inverse_Temperatures
)
)
}
M <- G()
library(graphics)
good_levels <- pretty(range(Liang_Distribution_Values, finite=TRUE), 20)
colorRampPalette(c('dark red','white','dark blue'))
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = good_levels,
col=terrain.colors(length(good_levels)-1)
)
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = good_levels,
col=colorRampPalette(c("white", "blue"), space = "Lab")(length(good_levels)-1)
)
nlevels = 20
filled.contour(x = Grid,
y = Grid,
z = Liang_Distribution_Values,
color.palette = cm.colors,
levels = pretty(nlevels), nlevels = 20,
col=color.palette(length(nlevels)-1)
)
nlevels = 15
contour(
x = Grid,
y = Grid,
z = Liang_Distribution_Values,
xlim = range(Grid, finite = TRUE),
ylim = range(Grid, finite = TRUE),
zlim = range(Liang_Distribution_Values, finite = TRUE),
levels = pretty( range(Liang_Distribution_Values, finite = TRUE), nlevels)
)
range(Grid, finite = TRUE)[1]
points(c(4,8)+c(range(Grid, finite = TRUE)[1]
,range(Grid, finite = TRUE)[1]
))
points(c(0,0))
library(ggplot2)
head(Liang_Distribution_Values)
dim(Liang_Distribution_Values)
library(reshape2)
volcano3d <- melt(volcano)
names(volcano3d) <- c("x", "y", "z")
head(volcano3d)
source("./Distributions_to_check/tested_distribution.R")
Liang_Distribution_Values_2   <- OTHER_VALUE_ESTABLISHER(Grid, LIANG_TARGET_DENSITY)
source("./Distributions_to_check/tested_distribution.R")
Liang_Distribution_Values_2   <- OTHER_VALUE_ESTABLISHER(Grid, LIANG_TARGET_DENSITY)
head(Liang_Distribution_Values_2)
OTHER_VALUE_ESTABLISHER <- function( grid,   FUNCTION_INPUT )
{
tmp <- length(grid)
Z 	<- matrix(nrows=tmp^2, ncol=3)
for( j in 1:tmp)
{
for(i in 1:tmp)
{
Z[i+j,3] <- i
Z[i+j,3] <- j
Z[i+j,3] <- FUNCTION_INPUT(c(grid[i], grid[j]))
}
}
return(Z)
}
OTHER_VALUE_ESTABLISHER(1:10, LIANG_TARGET_DENSITY)
OTHER_VALUE_ESTABLISHER <- function( grid,   FUNCTION_INPUT )
{
tmp <- length(grid)
Z 	<- matrix(nrow=tmp^2, ncol=3)
for( j in 1:tmp)
{
for(i in 1:tmp)
{
Z[i+j,3] <- i
Z[i+j,3] <- j
Z[i+j,3] <- FUNCTION_INPUT(c(grid[i], grid[j]))
}
}
return(Z)
}
OTHER_VALUE_ESTABLISHER(1:10, LIANG_TARGET_DENSITY)
OTHER_VALUE_ESTABLISHER(Grid[1:10], LIANG_TARGET_DENSITY)
OTHER_VALUE_ESTABLISHER <- function( grid,   FUNCTION_INPUT )
{
tmp <- length(grid)
Z 	<- matrix(nrow=tmp^2, ncol=3)
for( j in 1:tmp)
{
for(i in 1:tmp)
{
Z[i+(j-1)*tmp,1] <- i
Z[i+(j-1)*tmp,2] <- j
Z[i+(j-1)*tmp,3] <- FUNCTION_INPUT(c(grid[i], grid[j]))
}
}
return(Z)
}
OTHER_VALUE_ESTABLISHER(Grid[1:10], LIANG_TARGET_DENSITY)
OTHER_VALUE_ESTABLISHER <- function( grid,   FUNCTION_INPUT )
{
tmp <- length(grid)
Z 	<- matrix(nrow=tmp^2, ncol=3)
for( j in 1:tmp)
{
for(i in 1:tmp)
{
Z[i+(j-1)*tmp,1] <- grid[i]
Z[i+(j-1)*tmp,2] <- grid[j]
Z[i+(j-1)*tmp,3] <- FUNCTION_INPUT(c(grid[i], grid[j]))
}
}
return(Z)
}
OTHER_VALUE_ESTABLISHER(Grid[1:10], LIANG_TARGET_DENSITY)
OTHER_VALUE_ESTABLISHER(Grid[1:5], LIANG_TARGET_DENSITY)
data <- OTHER_VALUE_ESTABLISHER(Grid[1:5], LIANG_TARGET_DENSITY)
names(data) <- c("x", "y", "z")
head(data)
v <- ggplot(data, aes(x, y, z =z ))
data <- OTHER_VALUE_ESTABLISHER(Grid[1:5], LIANG_TARGET_DENSITY)
data <-as.data.frame( OTHER_VALUE_ESTABLISHER(Grid[1:5], LIANG_TARGET_DENSITY) )
names(data) <- c("x", "y", "z")
head(data)
v <- ggplot(data, aes(x, y, z =z ))
v+ + stat_contour()
v + stat_contour()
v + stat_contour()
data <-as.data.frame( OTHER_VALUE_ESTABLISHER(Grid, LIANG_TARGET_DENSITY) )
names(data) <- c("x", "y", "z")
head(data)
v <- ggplot(data, aes(x, y, z =z ))
v + stat_contour()
write.csv2(data, "./Data/Liang_Density_Values_For_Contour_gg2plot.csv", row.names=FALSE, col.names=FALSE)
v + stat_contour() + theme_bw()
v + stat_contour() + theme_bw() + geom_point(data = c(0,0))
data2 <- as.data.frame(
matrix( c(0,0),
nrow=1,
ncol=1
)
)
data2                      )
names(data2) <- c("x", "y")
data2 <- as.data.frame(
matrix( c(0,0),
nrow=1,
ncol=2
)
)
names(data2) <- c("x", "y")
data2
v + stat_contour() + theme_bw() + geom_point(data = data2)
v + stat_contour() + theme_bw() + geom_point(data = data2, aes(x=x, y=y))
data2 <- as.data.frame(
matrix( c(0,0,1,1),
nrow=1,
ncol=2
ncol=2
)
data2 <- as.data.frame(
matrix( c(0,0,1,1),
nrow=2,
ncol=2
)
)
names(data2) <- c("x", "y")
data2
v + stat_contour() + theme_bw() + geom_point(data = data2, aes(x=x, y=y))
v <- ggplot(data, aes(x, y, z =z ))
v + stat_contour() + theme_bw() + geom_point(data = data2, aes(x=x, y=y))
qplot(data2)
qplot(data = data2, x,y)
qplot(x,y, data = data2)
data2 <- as.data.frame(
matrix( c(0,0,1,1),
nrow=2,
ncol=2
)
)
names(data2) <- c("x", "y")
qplot(x,y, data = data2)
>>>>>>> f9ed98eafca4d784dfe0fb873c11ac9c91a06d42
